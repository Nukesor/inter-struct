# Inter-Struct

[![GitHub Actions Workflow](https://github.com/nukesor/inter-struct/workflows/Test%20build/badge.svg)](https://github.com/Nukesor/inter-struct/actions)
[![Crates.io](https://img.shields.io/crates/v/inter-struct)](https://crates.io/crates/inter-struct)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Downloads](https://img.shields.io/github/downloads/nukesor/inter-struct/total.svg)](https://github.com/nukesor/inter-struct/releases)

Various derive macros for trait implementations betwen two structs.

Please read the **known caveats** section before using this crate!
It's not trivial to implement code for two structs in the same codebase.

### Planned features: 

- [ ] PartialEq
- [x] StructMerge
- [x] StructMergeRef
- [x] Into - A standard `From/Into` impl between two structs.
- [x] IntoDefault - `From/Into`, but use `Default` on the target for unknown fields.

### StructMerge

```rust,ignore
/// Merge another struct into Self whilst consuming it.
/// 
/// The other trait is named `StructMergeRef` and merges other structs by reference.
pub trait StructMerge<Src> {
    /// Merge the given struct into self.
    fn merge(&mut self, src: Src);
}
```


This following code is an example on how to use the `InterStruct` derive macro for implementing the `StructMerge` trait between to structs.

```rust,ignore
use inter_struct::prelude::*;

/// The target struct we'll merge into.
pub struct Target {
    pub normal: String,
    pub optional: String,
    /// This field won't be touched as the macro cannot find a
    /// respective `ignored` field in the `Source` struct.
    pub ignored: Option<String>,
}

/// A struct with both an identical and an optional field type.
/// Note that the path to `Target` must always be fully qualifying.
#[derive(InterStruct)]
#[merge("crate::structs::Target")]
pub struct Source {
    pub normal: String,
    pub optional: Option<String>,
}

fn main() {
    let mut target = Target {
        normal: "target".to_string(),
        optional: "target".to_string(),
        ignored: "target".to_string(),
    };

    let source = Source {
        /// Has the same type as Target::normal
        normal: "source".to_string(),
        /// Wraps Target::optional in an Option
        optional: Some("source".to_string()),
    };

    // Merge the `Source` struct into target.
    target.merge(source);
    // You can also call this:
    // source.merge_into(target);
    assert_eq!(target.normal, "source".to_string());
    assert_eq!(target.optional, Some("source".to_string()));
    assert_eq!(target.ignored, "target".to_string());
}
```



## Known caveats

The main problems in this crate come from module resolution during.
There's no official way to resolve modules or types in the the procedural macro stage, which is why this crate only supports specific cases.

It's designed to work in this environment:

- In the scope of a single crate. Cross-crate usage won't work.
- In the main `src` folder of the crate. Integration tests and examples aren't supported.

Depending on your crate's structure, the module resolution might not work as expected.
As we're creating safe and valid Rust code the compiler will thrown an error if any problems arise.

Limitations in type resolution might also lead to wrong code generation for types that are obscured by type aliases, but the compiler should still throw errors in those cases.

#### Not yet solved problems

These are problems that can probably be solved but they're non-trivial.

- [ ] Struct located at root of crate. E.g. `lib.rs`.
- [ ] Struct is located in integration tests.
- [ ] Struct in (potentially nested or alternating) `mod {}` block in file.
- [ ] The source root dir isn't `src`.
      We would have to check the environment and possibly parse the `Cargo.toml`.
- [ ] Different generic aliases that use different tokens but have the same type.
        E.g.`Box<dyn T>` and `Box<dyn S>` but both `S` and `T` have the `Clone` trait bound.
- [ ] Non-public structs. I.e. structs that aren't fully internally visible.
    This will lead to an compiler-error but isn't cought while running this macro.
    This might be infeasible?

#### Unsolvable problems

These are problems that are either impossible to solve or very infeasible.
For instance, something infeasible would be to parse all files and to do a full type resolution of a given crate.
That would be a job for the compiler in later stages.

- Structs that are altered or generated by other macros.
- Type aliases. E.g. `type test = Option<String>` won't be detected as an Option.
    The current check for `Option` fields is a literal check for the `Option` token.
